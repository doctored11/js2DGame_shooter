/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/styles/style.css":
/*!******************************!*\
  !*** ./src/styles/style.css ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://js2dgame_shooter/./src/styles/style.css?");

/***/ }),

/***/ "./src/scripts/AliveObject.js":
/*!************************************!*\
  !*** ./src/scripts/AliveObject.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AliveObject: () => (/* binding */ AliveObject)\n/* harmony export */ });\n/* harmony import */ var _NonStaticGameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NonStaticGameObject.js */ \"./src/scripts/NonStaticGameObject.js\");\n\r\nclass AliveObject extends _NonStaticGameObject_js__WEBPACK_IMPORTED_MODULE_0__.NonStaticGameObjects {\r\n  constructor(\r\n    game,\r\n    posX,\r\n    posY,\r\n    collisionRad,\r\n    speedModificator,\r\n    hp = 100,\r\n    acceleration = 0.5\r\n  ) {\r\n    super(game, posX, posY, collisionRad);\r\n\r\n    this.speedClassicModificator = speedModificator;\r\n\r\n    this.speedX = 0;\r\n    this.speedY = 0;\r\n    this.dx = 0;\r\n    this.dy = 0;\r\n    this.speedModifier = this.speedClassicModificator;\r\n    this.standartHealPoint = hp;\r\n    this.healPoint = hp;\r\n    this.acceleration = acceleration;\r\n\r\n    this.aggressive = false;\r\n    this.scared = false;\r\n    this.target = null;\r\n    this.iq = Math.floor(Math.random() * 3);\r\n    this.defaultDirection = 0;\r\n    this.scorepPofitability = Math.random() * 15 + 5;\r\n    this.isDirectionMirrored = false\r\n  }\r\n\r\n  static catchTarget(catchingUp, target, speed, atack = true) {\r\n\r\n\r\n    let approachDistance =\r\n      catchingUp.gun == null ? 0 : catchingUp.gun.shotDistance * 0.8;\r\n\r\n\r\n    const dx = target.collisionX - catchingUp.collisionX;\r\n    const dy = target.collisionY - catchingUp.collisionY;\r\n    const distance = Math.hypot(dx, dy);\r\n\r\n    switch (catchingUp.iq) {\r\n      case 0:\r\n        approachDistance *= 0.6;\r\n        break;\r\n      case 1:\r\n        approachDistance *= 0.8;\r\n        break;\r\n      case 2:\r\n        approachDistance = approachDistance;\r\n        break;\r\n      case 3:\r\n        break;\r\n    }\r\n    approachDistance += catchingUp.collisionRadius / 2;\r\n\r\n\r\n    if (distance > approachDistance && atack) {\r\n      const unit_x = dx / distance;\r\n      const unit_y = dy / distance;\r\n\r\n      catchingUp.collisionX += unit_x * speed;\r\n      catchingUp.collisionY += unit_y * speed;\r\n    }\r\n    if (distance > 0 && !atack) {\r\n      const unit_x = dx / distance;\r\n      const unit_y = dy / distance;\r\n\r\n      catchingUp.collisionX += unit_x * speed;\r\n      catchingUp.collisionY += unit_y * speed;\r\n    }\r\n  }\r\n  ScanGameZone(searchArray, visibleArea) {\r\n    //возвращает ближнюю  цель или null\r\n    let closestDistance = Infinity;\r\n    let closestObject = null;\r\n\r\n    searchArray.forEach((searchObj) => {\r\n      const dx = searchObj.collisionX - this.collisionX;\r\n      const dy = searchObj.collisionY - this.collisionY;\r\n      const distance = Math.hypot(dx, dy);\r\n\r\n      if (distance < closestDistance) {\r\n        closestDistance = distance;\r\n        closestObject = searchObj;\r\n      }\r\n    });\r\n\r\n    if (closestObject && closestDistance < visibleArea) {\r\n      const dx = closestObject.collisionX - this.collisionX;\r\n      const dy = closestObject.collisionY - this.collisionY;\r\n      const distance = Math.hypot(dx, dy);\r\n\r\n      const unit_x = dx / distance;\r\n      const unit_y = dy / distance;\r\n\r\n      // Вместо изменения this, вернем массив с координатами\r\n      const newX = this.collisionX + unit_x * this.speed;\r\n      const newY = this.collisionY + unit_y * this.speed;\r\n\r\n      return closestObject;\r\n    }\r\n\r\n    // Если нет подходящего оружия, вернем null\r\n    return null;\r\n  }\r\n\r\n  static RanAwayFromTarget(\r\n    runAway,\r\n    target,\r\n    speed,\r\n    attentiveRadius = runAway.attentiveRadius || 500\r\n  ) {\r\n    const dx = target.collisionX - runAway.collisionX;\r\n    const dy = target.collisionY - runAway.collisionY;\r\n    const distance = Math.hypot(dx, dy);\r\n\r\n    // Если расстояние больше чем зона видимости в два раза\r\n    if (distance < attentiveRadius * 3) {\r\n      const unit_x = -dx / distance;\r\n      const unit_y = -dy / distance;\r\n      // if (runAway.speed > 3 * speed) runAway.speed = speed;\r\n      // runAway.speed += runAway.acceleration;\r\n\r\n      runAway.collisionX += unit_x * speed;\r\n      runAway.collisionY += unit_y * speed;\r\n    }\r\n  }\r\n\r\n  randomWalk() {\r\n    //перемещает объекты движением + возвращает на какое расстояние переместились\r\n\r\n    const changeDirectionChance = 5;\r\n    const randomShotChance = 15;\r\n\r\n    const randomNum = Math.random() * 100;\r\n\r\n    if (randomNum < changeDirectionChance) {\r\n      const angleChange = Math.random() * (Math.PI / 4) - Math.PI / 8;\r\n      this.defaultDirection += angleChange;\r\n    }\r\n    // if (this.gun != null && randomNum < randomShotChance) {\r\n    //   this.gun.shot(this, this.defaultDirection);\r\n    // }\r\n\r\n    const dx = Math.cos(this.defaultDirection) * this.speed;\r\n    const dy = Math.sin(this.defaultDirection) * this.speed;\r\n\r\n    if (this.borderLimit(0.7)) {\r\n      this.collisionX += dx;\r\n      this.collisionY += dy;\r\n    } else {\r\n      this.defaultDirection += Math.PI;\r\n    }\r\n    return [dx, dy];\r\n  }\r\n\r\n  static idleStatusCheck(attentiveRadius, executingObject, arrOfTargets) {\r\n    let dx, dy;\r\n    let angleOfMoving;\r\n    arrOfTargets.forEach((target) => {\r\n      // console.log(NonStaticGameObjects.getDistance(this, target))\r\n      if (\r\n        _NonStaticGameObject_js__WEBPACK_IMPORTED_MODULE_0__.NonStaticGameObjects.getDistance(executingObject, target) >\r\n        2 * attentiveRadius\r\n      ) {\r\n        executingObject.scared = false;\r\n      }\r\n\r\n      //в зоне видимости\r\n      if (\r\n        _NonStaticGameObject_js__WEBPACK_IMPORTED_MODULE_0__.NonStaticGameObjects.getDistance(executingObject, target) <\r\n        attentiveRadius\r\n      ) {\r\n        dx = target.collisionX - executingObject.collisionX;\r\n        dy = target.collisionY - executingObject.collisionY;\r\n\r\n        if (executingObject.gun == null) {\r\n          executingObject.scared = true;\r\n          executingObject.aggressive = false;\r\n        } else {\r\n          executingObject.scared = false;\r\n        }\r\n\r\n        if (!executingObject.scared && !executingObject.aggressive) {\r\n          AliveObject.catchTarget(\r\n            executingObject,\r\n            target,\r\n            executingObject.speed\r\n          );\r\n        } else if (!executingObject.scared && executingObject.aggressive) {\r\n          AliveObject.catchTarget(\r\n            executingObject,\r\n            target,\r\n            executingObject.speed * 1.5\r\n          );\r\n        } else {\r\n          let buffTarget = executingObject.ScanGameZone(\r\n            executingObject.game.pickableWeapons,\r\n            attentiveRadius / 3\r\n          );\r\n\r\n          if (buffTarget != null) {\r\n            AliveObject.catchTarget(\r\n              executingObject,\r\n              buffTarget,\r\n              executingObject.speed * 1.8\r\n            );\r\n\r\n            executingObject.aggressive = true;\r\n          } else {\r\n            AliveObject.RanAwayFromTarget(\r\n              executingObject,\r\n              target,\r\n              executingObject.speed * 1.6,\r\n              attentiveRadius\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      //не в зоне видимости\r\n      else if (!executingObject.scared && !executingObject.aggressive) {\r\n        const buffTarget = executingObject.ScanGameZone(\r\n          executingObject.game.pickableWeapons,\r\n          attentiveRadius\r\n        );\r\n\r\n        if (buffTarget != null) {\r\n          AliveObject.catchTarget(\r\n            executingObject,\r\n            buffTarget,\r\n            executingObject.speed,\r\n            false\r\n          );\r\n          dx = buffTarget.collisionX - executingObject.collisionX;\r\n          dy = buffTarget.collisionY - executingObject.collisionY;\r\n        } else {\r\n          [dx, dy] = executingObject.randomWalk();\r\n        }\r\n      } else if (\r\n        !executingObject.scared &&\r\n        executingObject.aggressive &&\r\n        executingObject.gun != null\r\n      ) {\r\n        AliveObject.catchTarget(executingObject, target, executingObject.speed);\r\n        dx = target.collisionX - executingObject.collisionX;\r\n        dy = target.collisionY - executingObject.collisionY;\r\n      } else if (executingObject.scared && !executingObject.aggressive) {\r\n        const buffTarget = executingObject.ScanGameZone(\r\n          executingObject.game.pickableWeapons,\r\n          attentiveRadius / 3\r\n        );\r\n\r\n        if (buffTarget != null) {\r\n          AliveObject.catchTarget(\r\n            executingObject,\r\n            buffTarget,\r\n            executingObject.speed\r\n          );\r\n\r\n          dx = buffTarget.collisionX - executingObject.collisionX;\r\n          dy = buffTarget.collisionY - executingObject.collisionY;\r\n        } else {\r\n          AliveObject.RanAwayFromTarget(\r\n            executingObject,\r\n            target,\r\n            executingObject.speed * 0.8,\r\n            attentiveRadius\r\n          );\r\n          dx = target.collisionX - executingObject.collisionX;\r\n          dy = target.collisionY - executingObject.collisionY;\r\n        }\r\n      } else {\r\n        [dx, dy] = executingObject.randomWalk();\r\n      }\r\n\r\n      angleOfMoving = Math.atan2(dy, dx);\r\n    });\r\n\r\n    return -angleOfMoving + Math.PI / 2;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://js2dgame_shooter/./src/scripts/AliveObject.js?");

/***/ }),

/***/ "./src/scripts/Armament.js":
/*!*********************************!*\
  !*** ./src/scripts/Armament.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Armament: () => (/* binding */ Armament)\n/* harmony export */ });\n/* harmony import */ var _Bullet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bullet.js */ \"./src/scripts/Bullet.js\");\n/* harmony import */ var _GameObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameObject.js */ \"./src/scripts/GameObject.js\");\n\r\n\r\n\r\nclass Armament {\r\n  constructor(\r\n    game,\r\n    shotDamage = 10,\r\n    shotSpeed = 10,\r\n    bulletsInShot = 1,\r\n    shotInterval = 200,\r\n    shotDistance = 600,\r\n    shotMode = \"single\",\r\n    type =\"enemy\"\r\n  ) {\r\n    this.game = game;\r\n    this.shotDamage = shotDamage;\r\n    this.shotSpeed = shotSpeed;\r\n    this.shotDistance = shotDistance;\r\n\r\n    this.bulletsInShot = bulletsInShot;\r\n    this.shotInterval = shotInterval;\r\n    this.shotMode = shotMode;\r\n\r\n    this.lastShotTime = 0;\r\n\r\n   \r\n    this.spriteHeight = 25 * game.pointScale;\r\n  }\r\n  draw(\r\n    context,\r\n    owner,\r\n    moveAngle,\r\n    image,\r\n    fillStyle = \"black\",\r\n    alfa = 1,\r\n    width = 50,\r\n    height = 13\r\n  ) {\r\n   \r\n    let angle = moveAngle;\r\n    if (owner == this.game.player) {\r\n      angle = this.game.mouseStatus.liveAngle;\r\n    }\r\n    // this.spriteX = owner.collisionX -  this.spriteHeight * 0.5;\r\n    // this.spriteY = owner.collisionY -  this.spriteHeight * 0.5;\r\n\r\n    const correctionAngle = -(angle - Math.PI / 2);\r\n\r\n    context.save();\r\n    context.translate(owner.collisionX, owner.collisionY);\r\n    context.rotate(correctionAngle);\r\n    context.translate(-this.spriteHeight * 0.5, -this.spriteHeight * 0.5);\r\n\r\n    if (angle < 0) {\r\n      context.save();\r\n      context.scale(1, -1); // Отражение по горизонтали\r\n\r\n      context.drawImage(\r\n        image,\r\n        0,\r\n        0 - this.spriteHeight,\r\n        this.spriteHeight,\r\n        this.spriteHeight\r\n      );\r\n\r\n      context.restore();\r\n    } else {\r\n      context.drawImage(image, 0, 0, this.spriteHeight, this.spriteHeight);\r\n    }\r\n\r\n    // Смещение\r\n\r\n    context.restore();\r\n  }\r\n\r\n  shot(owner, angle = 0) {\r\n    // console.log(owner);\r\n    const currentTime = Date.now();\r\n    if (currentTime - this.lastShotTime >= this.shotInterval) {\r\n      this.lastShotTime = currentTime;\r\n\r\n      // Создание и спавн пули здесь\r\n      for (let i = 0; i < this.bulletsInShot; i++) {\r\n        this.spawnBullet(owner, angle);\r\n      }\r\n    }\r\n  }\r\n  spawnBullet(owner, angleShot) {\r\n    const bulletSpawn = this.getBulletSpawn(owner, angleShot);\r\n    let collisionDetected = false;\r\n\r\n    this.game.globalSolidObjects.forEach((element) => {\r\n      if (_GameObject_js__WEBPACK_IMPORTED_MODULE_1__.GameObject.checkCollision(bulletSpawn, element).status) {\r\n        collisionDetected = true;\r\n        return;\r\n      }\r\n    });\r\n    if (collisionDetected) {\r\n      return;\r\n    }\r\n\r\n    const bullet = new _Bullet_js__WEBPACK_IMPORTED_MODULE_0__.Bullet(\r\n      this.game,\r\n      owner,\r\n      bulletSpawn.collisionX,\r\n      bulletSpawn.collisionY,\r\n      this.shotDamage,\r\n      this.shotSpeed,\r\n      this.shotDistance\r\n    );\r\n\r\n    let angle = angleShot;\r\n    if (owner == this.game.player) {\r\n      angle = this.game.mouseStatus.liveAngle;\r\n    }\r\n    const directionX = Math.sin(angle);\r\n    const directionY = Math.cos(angle);\r\n    bullet.setDirection(directionX, directionY);\r\n\r\n    // Добавьте созданную пулю в массив активных пуль вашей игры\r\n    this.game.activeBullets.push(bullet);\r\n  }\r\n  getBulletSpawn(owner, angle = 0) {\r\n    let correctionAngle = -angle;\r\n\r\n    if (owner == this.game.player) {\r\n      correctionAngle = -this.game.mouseStatus.liveAngle;\r\n    }\r\n\r\n    let rotatedX, rotatedY;\r\n\r\n    if (correctionAngle > 0) {\r\n      rotatedX =\r\n        owner.collisionX + this.spriteHeight * 0.15 * Math.cos(correctionAngle);\r\n      rotatedY =\r\n        owner.collisionY + this.spriteHeight * 0.15 * Math.sin(correctionAngle);\r\n    } else {\r\n      rotatedX =\r\n        owner.collisionX - this.spriteHeight * 0.15 * Math.cos(correctionAngle);\r\n      rotatedY =\r\n        owner.collisionY - this.spriteHeight * 0.15 * Math.sin(correctionAngle);\r\n    }\r\n\r\n    const edgeX =\r\n      rotatedX +\r\n      this.spriteHeight * 0.5 * Math.cos(correctionAngle + Math.PI / 2);\r\n    const edgeY =\r\n      rotatedY +\r\n      this.spriteHeight * 0.5 * Math.sin(correctionAngle + Math.PI / 2);\r\n\r\n    return {\r\n      collisionX: edgeX,\r\n      collisionY: edgeY,\r\n      collisionRadius: this.game.pointScale * 2,\r\n    };\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://js2dgame_shooter/./src/scripts/Armament.js?");

/***/ }),

/***/ "./src/scripts/Bullet.js":
/*!*******************************!*\
  !*** ./src/scripts/Bullet.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bullet: () => (/* binding */ Bullet)\n/* harmony export */ });\n/* harmony import */ var _GameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GameObject.js */ \"./src/scripts/GameObject.js\");\n/* harmony import */ var _NonStaticGameObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./NonStaticGameObject.js */ \"./src/scripts/NonStaticGameObject.js\");\n/* harmony import */ var _Player_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Player.js */ \"./src/scripts/Player.js\");\n\r\n\r\n\r\n\r\nclass Bullet extends _NonStaticGameObject_js__WEBPACK_IMPORTED_MODULE_1__.NonStaticGameObjects {\r\n  constructor(\r\n    game,\r\n    owner,\r\n    posX = 10,\r\n    posY = 10,\r\n    shotDamage = 10,\r\n    shotSpeed = 10,\r\n    shotDistanse = 300,\r\n    collisionRadius = game.pointScale * 1.5,\r\n    endurance = 10\r\n  ) {\r\n    super(game, posX, posY, collisionRadius);\r\n    this.owner = owner;\r\n    this.damage = shotDamage;\r\n    this.speed = shotSpeed;\r\n    this.shotDistanse = shotDistanse;\r\n    this.distanceTraveled = 0;\r\n    this.healPoint = endurance;\r\n  }\r\n  update(canTakeDamageArray) {\r\n    canTakeDamageArray.forEach((obj) => {\r\n      if (obj === this || obj == this.owner) return;\r\n      const collisionStatus = _GameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject.checkCollision(this, obj);\r\n\r\n      if (collisionStatus.status) {\r\n        obj.healPoint -= obj.armor !== undefined && obj.armor > 0 ? this.damage * 0.04 : this.damage;\r\n        obj.armor = obj.armor < 0 ? 0 : obj.armor - this.damage * 0.3\r\n        obj.aggressive = true;\r\n        this.destroy();\r\n      }\r\n    });\r\n    this.bulletMove();\r\n    super.update([...this.game.obstacles]);\r\n  }\r\n\r\n\r\n  setDirection(directionX, directionY) {\r\n    const distance = Math.hypot(directionX, directionY);\r\n    if (distance !== 0) {\r\n      this.directionX = directionX / distance;\r\n      this.directionY = directionY / distance;\r\n    }\r\n  }\r\n\r\n\r\n  bulletMove() {\r\n    if (this.distanceTraveled < this.shotDistanse) {\r\n      this.collisionX += this.directionX * this.speed;\r\n      this.collisionY += this.directionY * this.speed;\r\n      this.distanceTraveled += this.speed;\r\n    } else {\r\n  \r\n      this.destroy();\r\n    }\r\n  }\r\n\r\n  destroy() { //желатьльно через пул потом пули реализовать\r\n  \r\n    const index = this.game.activeBullets.indexOf(this);\r\n    if (index !== -1) {\r\n      this.game.activeBullets.splice(index, 1);\r\n    }\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://js2dgame_shooter/./src/scripts/Bullet.js?");

/***/ }),

/***/ "./src/scripts/Enemy.js":
/*!******************************!*\
  !*** ./src/scripts/Enemy.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Enemy: () => (/* binding */ Enemy)\n/* harmony export */ });\n/* harmony import */ var _AliveObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AliveObject.js */ \"./src/scripts/AliveObject.js\");\n/* harmony import */ var _NonStaticGameObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./NonStaticGameObject.js */ \"./src/scripts/NonStaticGameObject.js\");\n\r\n\r\n\r\nclass Enemy extends _AliveObject_js__WEBPACK_IMPORTED_MODULE_0__.AliveObject {\r\n  constructor(game, attentiveRadius = 650) {\r\n    super(game);\r\n    this.game = game;\r\n    this.collisionRadius = 5 * this.game.pointScale;\r\n\r\n    this.collisionX =\r\n      Math.random() * (this.game.spawnX - -this.game.spawnX) +\r\n      -this.game.spawnX;\r\n    this.collisionY =\r\n      Math.random() * (this.game.spawnY - -this.game.spawnY) +\r\n      -this.game.spawnY;\r\n\r\n    this.speed = Math.random() * this.game.player.speedModifier + this.game.player.speedModifier / 10;\r\n    this.gun = null;\r\n    this.armor = 0;\r\n    this.attentiveRadius = attentiveRadius;\r\n    this.isDirectionMirrored = false\r\n\r\n    this.spriteX = this.collisionX - this.width * 0.5;\r\n    this.spriteY = this.collisionY - this.height * 0.5;\r\n\r\n    this.image = new Image();\r\n    this.image.src = `../source/EnemySkin/enemy${this.iq}.png`;\r\n    this.imageGun = new Image();\r\n    this.imageGun.src = \"../source/EnemySkin/enemyGun.png\";\r\n\r\n\r\n  }\r\n  draw(context, moveAngle = 0) {\r\n    // super.draw(context, \"green\", 0.8);\r\n\r\n    if (this.isDirectionMirrored) {\r\n      context.save();\r\n      context.scale(-1, 1); // Отражение по горизонтали\r\n      context.drawImage(\r\n        this.image,\r\n        -this.spriteX - this.width, // начальная позиция по X на изображении (сдвиг влево)\r\n        this.spriteY,\r\n        this.width,\r\n        this.height\r\n      );\r\n      context.restore();\r\n    } else {\r\n      context.drawImage(\r\n        this.image,\r\n        this.spriteX,\r\n        this.spriteY,\r\n        this.width,\r\n        this.height\r\n      );\r\n    }\r\n    if (this.gun != null) this.gun.draw(context, this, moveAngle,this.imageGun);\r\n  }\r\n  update(context) {\r\n    super.update([this.game.player, ...this.game.globalSolidObjects]);\r\n    this.spriteX = this.collisionX - this.width * 0.5;\r\n    this.spriteY = this.collisionY - this.height * 0.5;\r\n\r\n\r\n    if (this.healPoint <= 0) {\r\n      this.destroy(this.game.enemies);\r\n    }\r\n\r\n    const angleMove = _AliveObject_js__WEBPACK_IMPORTED_MODULE_0__.AliveObject.idleStatusCheck(this.attentiveRadius, this, [\r\n      this.game.player,\r\n    ]);\r\n    this.isDirectionMirrored = false;\r\n    if (angleMove < 0.5) //?!!!!!!!!!!!!\r\n      this.isDirectionMirrored = true;\r\n\r\n    if (\r\n      this.gun != null &&\r\n      (_NonStaticGameObject_js__WEBPACK_IMPORTED_MODULE_1__.NonStaticGameObjects.getDistance(this, this.game.player) <\r\n        this.gun.shotDistance ||\r\n        this.aggressive)\r\n    ) {\r\n\r\n      this.gun.shot(this, angleMove);\r\n    }\r\n    this.draw(context, angleMove);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://js2dgame_shooter/./src/scripts/Enemy.js?");

/***/ }),

/***/ "./src/scripts/Game.js":
/*!*****************************!*\
  !*** ./src/scripts/Game.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Game: () => (/* binding */ Game)\n/* harmony export */ });\n/* harmony import */ var _Player_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Player.js */ \"./src/scripts/Player.js\");\n/* harmony import */ var _Enemy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Enemy.js */ \"./src/scripts/Enemy.js\");\n/* harmony import */ var _Obstacle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Obstacle.js */ \"./src/scripts/Obstacle.js\");\n/* harmony import */ var _MovingBarrier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MovingBarrier.js */ \"./src/scripts/MovingBarrier.js\");\n/* harmony import */ var _Armament_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Armament.js */ \"./src/scripts/Armament.js\");\n/* harmony import */ var _PickableWeapon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PickableWeapon.js */ \"./src/scripts/PickableWeapon.js\");\n/* harmony import */ var _PickableHealPoint_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PickableHealPoint.js */ \"./src/scripts/PickableHealPoint.js\");\n/* harmony import */ var _PickableArmorPoint_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PickableArmorPoint.js */ \"./src/scripts/PickableArmorPoint.js\");\n/* harmony import */ var _domHud_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./domHud.js */ \"./src/scripts/domHud.js\");\n/* harmony import */ var _script_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./script.js */ \"./src/scripts/script.js\");\n/* harmony import */ var _styles_style_css__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../styles/style.css */ \"./src/styles/style.css\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n \r\n\r\n\r\n\r\n\r\nclass Game {\r\n  constructor(canvas, hudsObj) {\r\n    this.canvas = canvas;\r\n    this.width = this.canvas.width;\r\n    this.height = this.canvas.height;\r\n\r\n    this.huds = hudsObj;\r\n    this.score = 0;\r\n    this.previousScore = 0;\r\n    this.gameEnd = false;\r\n\r\n    this.gameWidth = 6500;\r\n    this.gameHeight = this.gameWidth;\r\n\r\n    this.spawnX = (this.gameWidth * 0.8) / 2;\r\n    this.spawnY = (this.gameHeight * 0.8) / 2;\r\n\r\n    this.cameraX = 0;\r\n    this.cameraY = 0;\r\n    this.pointScale = 10;\r\n\r\n    this.player = new _Player_js__WEBPACK_IMPORTED_MODULE_0__.Player(this);\r\n    this.globalSolidObjects = [];\r\n\r\n    this.numberOfObstacles = (this.gameWidth / 60) * 0.4; //60 радиус камня\r\n    this.obstacles = [];\r\n\r\n    this.jumpTimer = 0;\r\n    this.jumpInterval = 1500;\r\n\r\n    this.spawnTimer = 0;\r\n    this.spawnInterval = 3000;\r\n    this.numberOfBox = this.numberOfObstacles * 0.8;\r\n    this.boxes = [];\r\n\r\n    this.numberOfEnemies = this.numberOfObstacles * 0.6 + 1;\r\n    this.enemies = [];\r\n\r\n    this.numberOfPickableWeapon = this.numberOfObstacles * 0.3 + 1;\r\n    this.pickableWeapons = [];\r\n\r\n    this.numberOfMedKits = this.numberOfEnemies / 4 + 1;\r\n    this.medKits = [];\r\n    this.armorDrop = []\r\n\r\n    this.activeBullets = [];\r\n\r\n    this.fps = 80;\r\n    this.timer = 0;\r\n    this.interval = 1000 / this.fps;\r\n\r\n    this.mouseStatus = {\r\n      x: this.width / 2,\r\n      y: this.height / 2,\r\n      pressed: false,\r\n      event: null,\r\n      action: null,\r\n      liveAngle: 0,\r\n    };\r\n\r\n\r\n    const values = this.player.modeValues;\r\n    let currentIndex = 0;\r\n    let accumulatedDeltaY = 0;\r\n    const scrollThreshold = 100; // Порог прокрутки, который нужно превысить, чтобы переключить элемент\r\n\r\n\r\n    // Привязываем обработчик события колесика мыши к документу\r\n    this.canvas.addEventListener(\"wheel\", (event) => {\r\n      accumulatedDeltaY += event.deltaY;\r\n\r\n      // Проверяем, превысила ли накопленная прокрутка порог\r\n      if (Math.abs(accumulatedDeltaY) >= scrollThreshold) {\r\n\r\n        if (accumulatedDeltaY > 0) {\r\n\r\n          currentIndex = (currentIndex + 1) % values.length;\r\n        } else {\r\n\r\n          currentIndex = (currentIndex - 1 + values.length) % values.length;\r\n        }\r\n\r\n        accumulatedDeltaY = 0;\r\n\r\n        this.changeModValue(currentIndex);\r\n      }\r\n    });\r\n\r\n    // Выводим текущий элемент в консоль при запуске скрипта\r\n    this.changeModValue();\r\n\r\n    this.canvas.addEventListener(\"mousedown\", (event) => {\r\n      console.log(event);\r\n\r\n      if (event.button === 0) {\r\n        this.player.isNavigate = false;\r\n        this.player.isJumping = false;\r\n\r\n        this.player.routePoints = [];\r\n        // console.log(this.enemies);\r\n        this.mouseStatus.x = event.offsetX - this.cameraX;\r\n        this.mouseStatus.y = event.offsetY - this.cameraY;\r\n        this.mouseStatus.pressed = true;\r\n      }\r\n      if (event.button === 2) {\r\n        this.mouseStatus.pressed = true;\r\n        if (this.player.isJumping) return;\r\n\r\n        (0,_domHud_js__WEBPACK_IMPORTED_MODULE_8__.setAttackMouse)();\r\n      }\r\n      if (event.button === 1) {\r\n        (0,_domHud_js__WEBPACK_IMPORTED_MODULE_8__.removeAttackMouse)();\r\n        (0,_domHud_js__WEBPACK_IMPORTED_MODULE_8__.setInteractionMouse)();\r\n        if (this.player.isJumping) return;\r\n        document.body.style.cursor = \"none\";\r\n        event.preventDefault();\r\n        this.mouseStatus.pressed = true;\r\n\r\n        //прыжок\r\n\r\n        if (this.player.modeAbility == \"jump\") {\r\n          this.player.isNavigate = false;\r\n          this.player.routePoints = [];\r\n          if (this.jumpTimer < this.jumpInterval) return;\r\n          this.mouseStatus.x = event.offsetX - this.cameraX;\r\n          this.mouseStatus.y = event.offsetY - this.cameraY;\r\n\r\n          [this.mouseStatus.x, this.mouseStatus.y] = this.player.fastJump(\r\n            event.offsetX - this.cameraX,\r\n            event.offsetY - this.cameraY\r\n          );\r\n        }\r\n        if (this.player.modeAbility == \"navigate\") {\r\n          //следование по точкам\r\n\r\n          if (this.player.routePoints.length < 3) {\r\n            this.player.isNavigate = true;\r\n            this.player.routePoints.push({\r\n              x: event.offsetX - this.cameraX,\r\n              y: event.offsetY - this.cameraY,\r\n            });\r\n            [this.mouseStatus.x, this.mouseStatus.y] =\r\n              this.player.followTheDots();\r\n          }\r\n          //\r\n        }\r\n      }\r\n    });\r\n\r\n    this.canvas.addEventListener(\"mouseup\", (event) => {\r\n      if (event.button === 0) {\r\n        (0,_domHud_js__WEBPACK_IMPORTED_MODULE_8__.removeAttackMouse)();\r\n        (0,_domHud_js__WEBPACK_IMPORTED_MODULE_8__.removeInteractionMouse)();\r\n        if (this.player.isJumping) return;\r\n        this.mouseStatus.x = event.offsetX - this.cameraX;\r\n        this.mouseStatus.y = event.offsetY - this.cameraY;\r\n        this.mouseStatus.pressed = false;\r\n      }\r\n      if (event.button === 1) {\r\n        document.body.style.cursor = \"none\";\r\n        (0,_domHud_js__WEBPACK_IMPORTED_MODULE_8__.removeAttackMouse)();\r\n        (0,_domHud_js__WEBPACK_IMPORTED_MODULE_8__.removeInteractionMouse)();\r\n        this.mouseStatus.pressed = false;\r\n      }\r\n    });\r\n\r\n    this.canvas.addEventListener(\"mousemove\", (event) => {\r\n      event.preventDefault();\r\n      if (this.mouseStatus.pressed) {\r\n        if (event.buttons === 1) {\r\n          (0,_domHud_js__WEBPACK_IMPORTED_MODULE_8__.removeAttackMouse)();\r\n          this.mouseStatus.x = event.offsetX - this.cameraX;\r\n          this.mouseStatus.y = event.offsetY - this.cameraY;\r\n        }\r\n        if (event.buttons === 2) {\r\n          event.preventDefault();\r\n          this.player.gun.shot(this.player);\r\n        }\r\n      }\r\n\r\n      this.mouseStatus.liveAngle = Math.atan2(\r\n        event.offsetX - this.cameraX - this.player.collisionX,\r\n        event.offsetY - this.cameraY - this.player.collisionY\r\n      );\r\n    });\r\n\r\n    this.canvas.addEventListener(\"contextmenu\", (event) => {\r\n      event.preventDefault();\r\n\r\n      (0,_domHud_js__WEBPACK_IMPORTED_MODULE_8__.removeAttackMouse)();\r\n      this.player.gun.shot(this.player);\r\n    });\r\n  }\r\n  changeModValue(currentIndex = 1) {\r\n    (0,_domHud_js__WEBPACK_IMPORTED_MODULE_8__.updateAbility)(currentIndex);\r\n    this.player.modeAbility = this.player.modeValues[currentIndex];\r\n    console.log(this.player.modeValues[currentIndex]);\r\n  }\r\n\r\n  render(context, deltaTime) {\r\n    if (this.gameEnd) {\r\n      saveScore(this.score);\r\n      (0,_script_js__WEBPACK_IMPORTED_MODULE_9__.displayBestScore)();\r\n      document.querySelector('.block-menu').classList.remove('display-none');\r\n\r\n      // alert(\"gameOver\");\r\n\r\n\r\n      return;\r\n    }\r\n    if (this.score != this.previousScore) {\r\n      (0,_domHud_js__WEBPACK_IMPORTED_MODULE_8__.changeScoreHud)(this.score, this.huds.score);\r\n      this.previousScore = this.score;\r\n    }\r\n\r\n    if (this.timer > this.interval) {\r\n      context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n      this.cameraX = this.canvas.width / 2 - this.player.collisionX; // Здесь player.x - это координата X игрока\r\n      this.cameraY = this.canvas.height / 2 - this.player.collisionY;\r\n\r\n      this.timer = 0;\r\n      context.translate(this.cameraX, this.cameraY);\r\n      this.drawBackground(context);\r\n\r\n      this.player.update();\r\n\r\n      this.activeBullets.forEach((bullet) => {\r\n        bullet.update([\r\n          ...this.boxes,\r\n          ...this.enemies,\r\n          ...this.activeBullets,\r\n          this.player,\r\n        ]);\r\n        bullet.draw(context);\r\n      });\r\n\r\n      //это для того чтоб дальние объекты не перекрывали передние\r\n      const allObjects = [\r\n        this.player,\r\n        ...this.obstacles,\r\n        ...this.boxes,\r\n        ...this.medKits,\r\n        ...this.armorDrop,\r\n        ...this.enemies,\r\n        ...this.pickableWeapons,\r\n      ];\r\n\r\n\r\n      allObjects.sort((a, b) => a.collisionY - b.collisionY);\r\n\r\n      allObjects.forEach((obj) => {\r\n        if (obj instanceof _Player_js__WEBPACK_IMPORTED_MODULE_0__.Player) {\r\n          obj.draw(context);\r\n        } else if (obj instanceof _Obstacle_js__WEBPACK_IMPORTED_MODULE_2__.Obstacle) {\r\n          obj.draw(context);\r\n        } else if (obj instanceof _MovingBarrier_js__WEBPACK_IMPORTED_MODULE_3__.MovingBarrier) {\r\n          obj.update();\r\n          obj.draw(context);\r\n        } else if (obj instanceof _PickableHealPoint_js__WEBPACK_IMPORTED_MODULE_6__.PickableHealPoints) {\r\n          obj.update([this.player, ...this.enemies]);\r\n          obj.draw(context);\r\n        } else if (obj instanceof _PickableArmorPoint_js__WEBPACK_IMPORTED_MODULE_7__.PickableArmorPoint) {\r\n          obj.update([this.player, ...this.enemies]);\r\n          obj.draw(context);\r\n        } else if (obj instanceof _Enemy_js__WEBPACK_IMPORTED_MODULE_1__.Enemy) {\r\n          obj.update(context);\r\n        } else if (obj instanceof _PickableWeapon_js__WEBPACK_IMPORTED_MODULE_5__.PickableWeapon) {\r\n          obj.update([this.player, ...this.enemies]);\r\n          obj.draw(context);\r\n        }\r\n      });\r\n\r\n      context.translate(-this.cameraX, -this.cameraY);\r\n    }\r\n    this.timer += deltaTime;\r\n\r\n    if (this.spawnTimer > this.spawnInterval) {\r\n      if (this.pickableWeapons.length < this.numberOfPickableWeapon)\r\n        this.addPickableWeapon();\r\n      if (this.boxes.length < this.numberOfBox) this.addBox();\r\n      if (this.enemies.length < this.numberOfEnemies) this.addEnemy();\r\n\r\n      this.spawnTimer = 0;\r\n    } else {\r\n      this.spawnTimer += deltaTime;\r\n    }\r\n    this.jumpTimer += deltaTime;\r\n  }\r\n  addPickableWeapon() {\r\n    const damage = getRandomNumber(0.02, 70);\r\n    const speed = getRandomNumber(0.3, 25);\r\n    const distance = getRandomNumber(200, 1000);\r\n    const interval = getRandomNumber(25, 1100);\r\n    const weapon = new _Armament_js__WEBPACK_IMPORTED_MODULE_4__.Armament(this, damage, speed, 1, interval, distance);\r\n    const pickableWeaponProto = new _PickableWeapon_js__WEBPACK_IMPORTED_MODULE_5__.PickableWeapon(this, weapon);\r\n\r\n    this.pickableWeapons.push(pickableWeaponProto);\r\n    this.globalSolidObjects.push(pickableWeaponProto);\r\n  }\r\n\r\n  addBox() {\r\n    const box = new _MovingBarrier_js__WEBPACK_IMPORTED_MODULE_3__.MovingBarrier(this);\r\n    this.boxes.push(box);\r\n    this.globalSolidObjects.push(box);\r\n  }\r\n  addEnemy() {\r\n    const en = new _Enemy_js__WEBPACK_IMPORTED_MODULE_1__.Enemy(this);\r\n    this.enemies.push(en);\r\n    this.globalSolidObjects.push(en);\r\n  }\r\n  addMedKit() {\r\n    const mk = new _PickableHealPoint_js__WEBPACK_IMPORTED_MODULE_6__.PickableHealPoints(this);\r\n    this.medKits.push(mk);\r\n  }\r\n  addArmorDrop(x, y) {\r\n    const ad = new _PickableArmorPoint_js__WEBPACK_IMPORTED_MODULE_7__.PickableArmorPoint(this, x, y);\r\n    this.armorDrop.push(ad);\r\n  }\r\n\r\n  init() {\r\n    for (let i = 0; i < this.numberOfEnemies; ++i) {\r\n      this.addEnemy();\r\n    }\r\n\r\n    for (let i = 0; i < this.numberOfBox; ++i) {\r\n      this.addBox();\r\n    }\r\n    for (let i = 0; i < this.numberOfMedKits; ++i) {\r\n      this.addMedKit();\r\n    }\r\n    for (let i = 0; i < this.numberOfPickableWeapon; ++i) {\r\n      this.addPickableWeapon();\r\n    }\r\n    console.log(this.pickableWeapons);\r\n\r\n    for (let i = 0; i < this.numberOfObstacles; ++i) {\r\n      let buffObs = new _Obstacle_js__WEBPACK_IMPORTED_MODULE_2__.Obstacle(this);\r\n      let checkOverlap = false;\r\n\r\n      this.obstacles.forEach((obs) => {\r\n        const dx = buffObs.collisionX - obs.collisionX;\r\n        const dy = buffObs.collisionY - obs.collisionY;\r\n\r\n        const dist = Math.hypot(dx, dy);\r\n        const sumOfRad = buffObs.collisionRadius + obs.collisionRadius;\r\n\r\n        if (dist < sumOfRad) {\r\n          checkOverlap = true;\r\n        }\r\n      });\r\n      if (!checkOverlap) {\r\n        this.obstacles.push(buffObs);\r\n        this.globalSolidObjects.push(buffObs);\r\n      }\r\n    }\r\n    this.globalSolidObjects.push(this.player);\r\n  }\r\n  canvasPaintDecor() {\r\n    context.strokeRect(0, 0, this.gameWidth, this.gameHeight);\r\n  }\r\n  drawBackground(context) {\r\n    context.save();\r\n    const multiplayer = 0.9;\r\n    const buffX = (this.gameWidth * multiplayer) / 2;\r\n    const buffY = (this.gameHeight * multiplayer) / 2;\r\n\r\n    const startX = 0;\r\n    const startY = 0;\r\n\r\n    // Отрисовка красных границ поля\r\n    context.strokeStyle = \"red\";\r\n    context.lineWidth = 10;\r\n\r\n    const leftBorder = Math.max(-buffX, startX - buffX);\r\n    const topBorder = Math.max(-buffY, startY - buffY);\r\n    const rightBorder = Math.min(buffX, startX + buffX);\r\n    const bottomBorder = Math.min(buffY, startY + buffY);\r\n\r\n    context.strokeRect(\r\n      leftBorder,\r\n      topBorder,\r\n      rightBorder - leftBorder,\r\n      bottomBorder - topBorder\r\n    );\r\n\r\n    context.restore();\r\n  }\r\n  gameRestart() {\r\n    this.gameEnd = false;\r\n    this.score = 0;\r\n\r\n    this.boxes = [];\r\n    this.enemies = [];\r\n    this.activeBullets = [];\r\n    this.player = new _Player_js__WEBPACK_IMPORTED_MODULE_0__.Player(this);\r\n    this.globalSolidObjects = [];\r\n    this.obstacles = [];\r\n    this.pickableWeapons = [];\r\n    this.medKits = [];\r\n    this.armorDrop = [];\r\n    this.init();\r\n\r\n\r\n  }\r\n\r\n\r\n}\r\nfunction getRandomNumber(min, max) {\r\n  return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n///\r\nfunction saveScore(score) {\r\n\r\n  if (typeof (Storage) !== \"undefined\") {\r\n\r\n    const oldScore = parseInt(localStorage.getItem(\"score\")) || 0;\r\n\r\n\r\n    if (score > oldScore) {\r\n\r\n      localStorage.setItem(\"score\", score);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://js2dgame_shooter/./src/scripts/Game.js?");

/***/ }),

/***/ "./src/scripts/GameObject.js":
/*!***********************************!*\
  !*** ./src/scripts/GameObject.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameObject: () => (/* binding */ GameObject)\n/* harmony export */ });\nclass GameObject {\r\n  constructor(\r\n    game,\r\n    posX,\r\n    posY,\r\n    collisionRadius = 4 * game.pointScale,\r\n    spriteWidth = 20* game.pointScale\r\n  ) {\r\n    this.game = game;\r\n    this.collisionX = posX;\r\n    this.collisionY = posY;\r\n    this.collisionRadius = collisionRadius;\r\n\r\n    this.spriteWidth = spriteWidth;\r\n    this.spriteHeight = spriteWidth;\r\n    this.width = this.spriteWidth;\r\n    this.height = this.spriteHeight;\r\n    this.image = null;\r\n\r\n    this.spriteX = this.collisionX - this.width * 0.5;\r\n    this.spriteY = this.collisionY - this.height * 0.5;\r\n  }\r\n  draw(context, fillStyle = \"gray\", alfa = 0.2) {\r\n    if (this.image != undefined) {\r\n      context.drawImage(\r\n        this.image,\r\n        this.spriteX,\r\n        this.spriteY,\r\n        this.width,\r\n        this.height\r\n      );\r\n    }else{\r\n    context.save();\r\n    context.fillStyle = fillStyle; //\r\n    context.globalAlpha = alfa;\r\n    context.beginPath();\r\n    context.arc(\r\n      this.collisionX,\r\n      this.collisionY,\r\n      this.collisionRadius,\r\n      0,\r\n      Math.PI * 2,\r\n      false\r\n    );\r\n    context.fill();\r\n    context.restore();\r\n    context.lineWidth = 5;\r\n    context.stroke();\r\n    //\r\n    context.beginPath();\r\n\r\n    context.save();\r\n    }\r\n    \r\n    context.restore();\r\n  }\r\n\r\n  static checkCollision(a, b) {\r\n    const dx = a.collisionX - b.collisionX;\r\n    const dy = a.collisionY - b.collisionY;\r\n    const dist = Math.hypot(dx, dy);\r\n    const sumOfRad = a.collisionRadius + b.collisionRadius;\r\n\r\n    return {\r\n      status: dist < sumOfRad,\r\n      distance: dist,\r\n      sumOfRad: sumOfRad,\r\n      dx: dx,\r\n      dy: dy,\r\n    };\r\n  }\r\n  static getDistance(a, b) {\r\n    const dx = a.collisionX - b.collisionX;\r\n    const dy = a.collisionY - b.collisionY;\r\n    const dist = Math.hypot(dx, dy);\r\n    return dist;\r\n  }\r\n  borderLimit(acceptablePart = 0.99) {\r\n    // console.log(this.collisionX, this.collisionY);\r\n    if (acceptablePart > 2) acceptablePart = 2;\r\n    if (acceptablePart <= 0) acceptablePart = 0.5;\r\n    let inZone = true;\r\n\r\n    if (this.collisionX < -(this.game.gameWidth * acceptablePart) / 2) {\r\n      inZone = false;\r\n      this.collisionX = -(this.game.gameWidth * acceptablePart) / 2;\r\n    } else if (this.collisionX > (this.game.gameWidth * acceptablePart) / 2) {\r\n      inZone = false;\r\n      this.collisionX = (this.game.gameWidth * acceptablePart) / 2;\r\n    }\r\n\r\n    if (this.collisionY < -(this.game.gameHeight * acceptablePart) / 2) {\r\n      inZone = false;\r\n      this.collisionY = -(this.game.gameHeight * acceptablePart) / 2;\r\n    } else if (this.collisionY > (this.game.gameHeight * acceptablePart) / 2) {\r\n      inZone = false;\r\n      this.collisionY = (this.game.gameHeight * acceptablePart) / 2;\r\n    }\r\n    return inZone;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://js2dgame_shooter/./src/scripts/GameObject.js?");

/***/ }),

/***/ "./src/scripts/MovingBarrier.js":
/*!**************************************!*\
  !*** ./src/scripts/MovingBarrier.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MovingBarrier: () => (/* binding */ MovingBarrier)\n/* harmony export */ });\n/* harmony import */ var _NonStaticGameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NonStaticGameObject.js */ \"./src/scripts/NonStaticGameObject.js\");\n/* harmony import */ var _PickableHealPoint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PickableHealPoint.js */ \"./src/scripts/PickableHealPoint.js\");\n/* harmony import */ var _PickableArmorPoint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PickableArmorPoint.js */ \"./src/scripts/PickableArmorPoint.js\");\n/* harmony import */ var _GameObject_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GameObject.js */ \"./src/scripts/GameObject.js\");\n\r\n\r\n\r\n\r\n\r\nclass MovingBarrier extends _NonStaticGameObject_js__WEBPACK_IMPORTED_MODULE_0__.NonStaticGameObjects {\r\n  constructor(game, hp = 40) {\r\n\r\n    super(\r\n      game,\r\n      Math.random() * (game.spawnX - -game.spawnX) + -game.spawnX,\r\n      Math.random() * (game.spawnY - -game.spawnY) + -game.spawnY,\r\n      game.pointScale * 5,\r\n      game.pointScale * 30,\r\n\r\n    );\r\n\r\n    this.image = new Image();\r\n    this.image.src = \"../source/environment/box.png\";\r\n    this.healPoint = hp;\r\n  }\r\n  draw(context) {\r\n    super.draw(context, \"brown\", 0.6);\r\n  }\r\n  update() {\r\n    this.spriteX = this.collisionX - this.width * 0.5;\r\n    this.spriteY = this.collisionY - this.height * 0.5;\r\n    super.update([\r\n      this.game.player,\r\n      ...this.game.obstacles,\r\n      ...this.game.boxes,\r\n    ]); //чтоб мобы не толкали(this.game.obstacles)\r\n\r\n    if (this.healPoint <= 0) {\r\n      this.destroy(this.game.boxes);\r\n    }\r\n    this.borderLimit(1);\r\n  }\r\n  destroy(arrayOfAlivesType) {\r\n    super.destroy(arrayOfAlivesType);\r\n    if (this.hasPercentChance(15)) {\r\n      const ad = new _PickableArmorPoint_js__WEBPACK_IMPORTED_MODULE_2__.PickableArmorPoint(this.game, this.collisionX, this.collisionY);\r\n      this.game.armorDrop.push(ad);\r\n    } else if (this.hasPercentChance(45)) {\r\n      const mk = new _PickableHealPoint_js__WEBPACK_IMPORTED_MODULE_1__.PickableHealPoints(this.game, this.collisionX, this.collisionY);\r\n      this.game.medKits.push(mk);\r\n    }\r\n\r\n  }\r\n  hasPercentChance(percent) {\r\n\r\n    const randomNumber = Math.random() * 100;\r\n\r\n\r\n    return randomNumber <= percent;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://js2dgame_shooter/./src/scripts/MovingBarrier.js?");

/***/ }),

/***/ "./src/scripts/NonStaticGameObject.js":
/*!********************************************!*\
  !*** ./src/scripts/NonStaticGameObject.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NonStaticGameObjects: () => (/* binding */ NonStaticGameObjects)\n/* harmony export */ });\n/* harmony import */ var _GameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GameObject.js */ \"./src/scripts/GameObject.js\");\n\r\n\r\nclass NonStaticGameObjects extends _GameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject {\r\n  constructor(game, posX, posY, collisionRadius, spriteWidth = 20* game.pointScale) {\r\n    super(game, posX, posY, collisionRadius,spriteWidth);\r\n    this.scorepPofitability = Math.random() * 2 + 1;\r\n  }\r\n\r\n  update(colisionArr) {\r\n    let collisonObject = colisionArr\r\n    collisonObject.forEach((obj) => {\r\n      if (obj === this) return;\r\n      const collisionStatus = _GameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject.checkCollision(this, obj);\r\n\r\n      if (collisionStatus.status) {\r\n        const unit_x = collisionStatus.dx / collisionStatus.distance;\r\n        const unit_y = collisionStatus.dy / collisionStatus.distance;\r\n        this.collisionX =\r\n          obj.collisionX + (collisionStatus.sumOfRad + 1) * unit_x;\r\n        this.collisionY =\r\n          obj.collisionY + (collisionStatus.sumOfRad + 1) * unit_y;\r\n      }\r\n    });\r\n    this.borderLimit(1);\r\n  }\r\n  destroy(arrayOfAlivesType) {\r\n    const indexInLocal = arrayOfAlivesType.indexOf(this);\r\n    const indexInGlobal = this.game.globalSolidObjects.indexOf(this);\r\n\r\n    arrayOfAlivesType.splice(indexInLocal, 1);\r\n    this.game.globalSolidObjects.splice(indexInGlobal, 1);\r\n\r\n    this.game.score+=this.scorepPofitability\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://js2dgame_shooter/./src/scripts/NonStaticGameObject.js?");

/***/ }),

/***/ "./src/scripts/Obstacle.js":
/*!*********************************!*\
  !*** ./src/scripts/Obstacle.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Obstacle: () => (/* binding */ Obstacle)\n/* harmony export */ });\n/* harmony import */ var _GameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GameObject.js */ \"./src/scripts/GameObject.js\");\n\r\n\r\nclass Obstacle extends _GameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject {\r\n  constructor(game) {\r\n    super(\r\n      game,\r\n      Math.random() * (game.spawnX - -game.spawnX) + -game.spawnX,\r\n      Math.random() * (game.spawnY - -game.spawnY) + -game.spawnY,\r\n      16 * game.pointScale,\r\n      110 * game.pointScale\r\n    );\r\n    this.image = new Image();\r\n    this.image.src = \"../source/environment/mountain.png\";\r\n  }\r\n\r\n  draw(context) {\r\n    super.draw(context, \"gray\", 0.6);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://js2dgame_shooter/./src/scripts/Obstacle.js?");

/***/ }),

/***/ "./src/scripts/PickableArmorPoint.js":
/*!*******************************************!*\
  !*** ./src/scripts/PickableArmorPoint.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PickableArmorPoint: () => (/* binding */ PickableArmorPoint)\n/* harmony export */ });\n/* harmony import */ var _NonStaticGameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NonStaticGameObject.js */ \"./src/scripts/NonStaticGameObject.js\");\n/* harmony import */ var _GameObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameObject.js */ \"./src/scripts/GameObject.js\");\n\r\n\r\n\r\nclass PickableArmorPoint extends _NonStaticGameObject_js__WEBPACK_IMPORTED_MODULE_0__.NonStaticGameObjects {\r\n    constructor(game, x, y) {\r\n        super(\r\n            game,\r\n            x,\r\n            y,\r\n            25\r\n        );\r\n        this.armorValue = Math.random() * (500 - 50) + 50;\r\n        this.scorePofitability = 10;\r\n        this.image = new Image();\r\n        this.image.src = \"../source/environment/armor.png\";\r\n    }\r\n    draw(context) {\r\n        super.draw(context, \"blue\", 0.5);\r\n    }\r\n    update(canTakeArray) {\r\n        this.spriteX = this.collisionX - this.width * 0.5;\r\n        this.spriteY = this.collisionY - this.height * 0.5;\r\n        super.update([...this.game.boxes, ...this.game.obstacles]);\r\n        canTakeArray.forEach((el) => {\r\n            if (el === this) return;\r\n            const collisionStatus = _GameObject_js__WEBPACK_IMPORTED_MODULE_1__.GameObject.checkCollision(this, el);\r\n\r\n            if (collisionStatus.status && el.armor != undefined) {\r\n                console.log(\"taken\" + el.armor)\r\n                el.armor += this.armorValue;\r\n                el.scared = false;\r\n                this.destroy(this.game.armorDrop);\r\n            }\r\n        });\r\n    }\r\n    destroy(arrOfSameTypes) {\r\n        const indexInLocal = arrOfSameTypes.indexOf(this);\r\n        arrOfSameTypes.splice(indexInLocal, 1);\r\n\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://js2dgame_shooter/./src/scripts/PickableArmorPoint.js?");

/***/ }),

/***/ "./src/scripts/PickableHealPoint.js":
/*!******************************************!*\
  !*** ./src/scripts/PickableHealPoint.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PickableHealPoints: () => (/* binding */ PickableHealPoints)\n/* harmony export */ });\n/* harmony import */ var _NonStaticGameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NonStaticGameObject.js */ \"./src/scripts/NonStaticGameObject.js\");\n/* harmony import */ var _GameObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameObject.js */ \"./src/scripts/GameObject.js\");\n\r\n\r\n\r\nclass PickableHealPoints extends _NonStaticGameObject_js__WEBPACK_IMPORTED_MODULE_0__.NonStaticGameObjects {\r\n  constructor(game, x = Math.random() * (game.spawnX - -game.spawnX) + -game.spawnX, y = Math.random() * (game.spawnY - -game.spawnY) + -game.spawnY) {\r\n    super(\r\n      game,\r\n      x,\r\n      y,\r\n      20, \r\n      15 * game.pointScale\r\n    );\r\n    this.healValue = Math.random() * (40 - 5) + 5;\r\n    this.scorePofitability = 1;\r\n    this.image = new Image();\r\n    this.image.src = \"../source/environment/heal.png\";\r\n  }\r\n  draw(context) {\r\n    super.draw(context, \"blue\", 0.2);\r\n  }\r\n  update(canTakeArray) {\r\n    this.spriteX = this.collisionX - this.width * 0.5;\r\n    this.spriteY = this.collisionY - this.height * 0.5;\r\n    super.update([...this.game.boxes, ...this.game.obstacles]);\r\n    canTakeArray.forEach((el) => {\r\n      if (el === this) return;\r\n      const collisionStatus = _GameObject_js__WEBPACK_IMPORTED_MODULE_1__.GameObject.checkCollision(this, el);\r\n\r\n      if (collisionStatus.status) {\r\n        el.healPoint += this.healValue;\r\n        el.scared = false;\r\n        this.destroy(this.game.medKits);\r\n      }\r\n    });\r\n  }\r\n  destroy(arrOfSameTypes) {\r\n    const indexInLocal = arrOfSameTypes.indexOf(this);\r\n\r\n\r\n    arrOfSameTypes.splice(indexInLocal, 1);\r\n\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://js2dgame_shooter/./src/scripts/PickableHealPoint.js?");

/***/ }),

/***/ "./src/scripts/PickableWeapon.js":
/*!***************************************!*\
  !*** ./src/scripts/PickableWeapon.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PickableWeapon: () => (/* binding */ PickableWeapon)\n/* harmony export */ });\n/* harmony import */ var _GameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GameObject.js */ \"./src/scripts/GameObject.js\");\n/* harmony import */ var _NonStaticGameObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./NonStaticGameObject.js */ \"./src/scripts/NonStaticGameObject.js\");\n\r\n\r\n\r\nclass PickableWeapon extends _NonStaticGameObject_js__WEBPACK_IMPORTED_MODULE_1__.NonStaticGameObjects {\r\n  constructor(game, armamentProto) {\r\n    super(\r\n      game,\r\n      Math.random() * (game.spawnX - -game.spawnX) + -game.spawnX,\r\n      Math.random() * (game.spawnY - -game.spawnY) + -game.spawnY,\r\n      2.5 * game.pointScale,10* game.pointScale\r\n    );\r\n    this.armamentProto = armamentProto;\r\n   \r\n    this.image = new Image();\r\n    this.image.src = \"../source/environment/armament.png\";\r\n  }\r\n\r\n  draw(context) {\r\n    super.draw(context, \"gray\", 0.8);\r\n  }\r\n  update(weaponHoldersArray) {\r\n    this.spriteX = this.collisionX - this.width * 0.5;\r\n    this.spriteY = this.collisionY - this.height * 0.5;\r\n    super.update([...this.game.boxes, ...this.game.obstacles]);\r\n    weaponHoldersArray.forEach((holder) => {\r\n      if (holder === this) return;\r\n      const collisionStatus = _GameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject.checkCollision(this, holder);\r\n\r\n      if (collisionStatus.status) {\r\n        holder.gun = this.armamentProto;\r\n        holder.gun.holderPosition = {\r\n          x: holder.collosionX,\r\n          y: holder.collosionY,\r\n        };\r\n        holder.scared = false;\r\n        this.destroy(this.game.pickableWeapons);\r\n      }\r\n    });\r\n  }\r\n  destroy(arrOfSameTypes) {\r\n    const indexInLocal = arrOfSameTypes.indexOf(this);\r\n    const indexInGlobal = this.game.globalSolidObjects.indexOf(this);\r\n\r\n    arrOfSameTypes.splice(indexInLocal, 1);\r\n    this.game.globalSolidObjects.splice(indexInGlobal, 1);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://js2dgame_shooter/./src/scripts/PickableWeapon.js?");

/***/ }),

/***/ "./src/scripts/Player.js":
/*!*******************************!*\
  !*** ./src/scripts/Player.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Player: () => (/* binding */ Player)\n/* harmony export */ });\n/* harmony import */ var _AliveObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AliveObject.js */ \"./src/scripts/AliveObject.js\");\n/* harmony import */ var _Armament_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Armament.js */ \"./src/scripts/Armament.js\");\n/* harmony import */ var _domHud_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./domHud.js */ \"./src/scripts/domHud.js\");\n\r\n\r\n\r\n\r\n\r\nlet bufferHp = 0;\r\nlet bufferArmor = 0;\r\n\r\nconst abilityBack1 = document.getElementById(\"ability-1\");\r\nconst abilityBack2 = document.getElementById(\"ability-2\");\r\nclass Player extends _AliveObject_js__WEBPACK_IMPORTED_MODULE_0__.AliveObject {\r\n  constructor(game) {\r\n    super(game, game.width / 2, game.height / 2, 5 * game.pointScale, 3);\r\n    this.gun = new _Armament_js__WEBPACK_IMPORTED_MODULE_1__.Armament(game, 20, 15, 1, 200, 500, \"single\", \"player\");\r\n\r\n    this.routePoints = [];\r\n    this.isNavigate = false;\r\n    this.isJumping = false;\r\n    this.statJumpX = null;\r\n    this.startJumpY = null;\r\n    this.distanceTraveled = 0;\r\n    this.jumpBoost = 12;\r\n    this.jumpMaxDistance = this.game.gameWidth * 0.05;\r\n    this.standartHealPoint = 100;\r\n    this.armor = 1;\r\n    this.healPoint = this.standartHealPoint;\r\n    this.modeAbility = \"navigate\";\r\n\r\n    this.spriteX = this.collisionX - this.width * 0.5;\r\n    this.spriteY = this.collisionY - this.height * 0.5;\r\n\r\n    this.image = new Image();\r\n    this.image.src = \"../source/PlayerSkin/player.png\";\r\n    this.imageGun = new Image();\r\n    this.imageGun.src = \"../source/PlayerSkin/playerGun.png\";\r\n    // this.spriteHeight = 250;\r\n\r\n    this.modeValues = [null, \"navigate\", \"jump\"];\r\n  }\r\n\r\n  draw(context) {\r\n    const fillPercentage = (3 - this.routePoints.length) / 3 * 100\r\n    abilityBack1.style.height = `${fillPercentage}%`;\r\n    const jumpTimerPercentage = 100 - (this.game.jumpInterval - this.game.jumpTimer) / this.game.jumpInterval * 100;\r\n    abilityBack2.style.height = `${jumpTimerPercentage}%`;\r\n\r\n    if (this.isJumping && this.game.jumpTimer > this.game.jumpInterval)\r\n      this.paintJumpLine(context);\r\n    else if (this.routePoints.length > 0) {\r\n      this.paintСurvedLine(context);\r\n\r\n      //\r\n    } else {\r\n      this.paintStraightLine(context);\r\n    }\r\n\r\n    // super.draw(context, \"red\", 0.1);\r\n\r\n    if (this.isDirectionMirrored) {\r\n      context.save();\r\n      context.scale(-1, 1); // Отражение по горизонтали\r\n      context.drawImage(\r\n        this.image,\r\n        -this.spriteX - this.width, // начальная позиция по X на изображении (сдвиг влево)\r\n        this.spriteY,\r\n        this.width,\r\n        this.height\r\n      );\r\n      context.restore();\r\n    } else {\r\n      context.drawImage(\r\n        this.image,\r\n        this.spriteX,\r\n        this.spriteY,\r\n        this.width,\r\n        this.height\r\n      );\r\n    }\r\n    this.gun.draw(context, this,undefined,this.imageGun);\r\n  }\r\n  update() {\r\n    this.spriteX = this.collisionX - this.width * 0.5;\r\n    this.spriteY = this.collisionY - this.height * 0.5;\r\n    if (bufferHp != this.healPoint) {\r\n      (0,_domHud_js__WEBPACK_IMPORTED_MODULE_2__.changeHpHud)(this.healPoint, this.standartHealPoint, this.game.huds.hp);\r\n      bufferHp = this.healPoint;\r\n    }\r\n    if (bufferArmor != this.armor) {\r\n      (0,_domHud_js__WEBPACK_IMPORTED_MODULE_2__.changeArmorHud)(this.armor, this.game.huds.armor);\r\n      bufferArmor = this.armorPoint;\r\n    }\r\n    if (this.healPoint <= 0) this.game.gameEnd = true;\r\n\r\n    if (this.isNavigate) {\r\n      [this.game.mouseStatus.x, this.game.mouseStatus.y] = this.followTheDots();\r\n    }\r\n    if (this.isJumping && this.game.jumpTimer > this.game.jumpInterval) {\r\n      this.collisionX += this.speedX * (this.speedModifier + this.jumpBoost);\r\n      this.collisionY += this.speedY * (this.speedModifier + this.jumpBoost);\r\n      [this.game.mouseStatus.x, this.game.mouseStatus.y] = this.fastJump(\r\n        this.game.mouseStatus.x,\r\n        this.game.mouseStatus.y\r\n      );\r\n    }\r\n    //////!!101\r\n    this.isDirectionMirrored = false;\r\n    if (this.game.mouseStatus.x < this.collisionX)\r\n      this.isDirectionMirrored = true;\r\n\r\n    this.dx = this.game.mouseStatus.x - this.collisionX;\r\n    this.dy = this.game.mouseStatus.y - this.collisionY;\r\n\r\n    const distance = Math.hypot(this.dx, this.dy);\r\n    if (distance < this.speedModifier) return;\r\n    this.speedX = this.dx / distance || 0;\r\n    this.speedY = this.dy / distance || 0;\r\n\r\n    //\r\n\r\n    this.collisionX += this.speedX * this.speedModifier;\r\n    this.collisionY += this.speedY * this.speedModifier;\r\n\r\n    super.update([this.game.player, ...this.game.obstacles]); //тут только камни ( чтоб мог толкать коробки и прочее)\r\n  }\r\n\r\n  followTheDots() {\r\n    const arrayOfObjectsWithCoords = this.routePoints;\r\n    if (arrayOfObjectsWithCoords.length === 0) {\r\n      this.isNavigate = false;\r\n      // Все точки обойдены, просто останавливаемся\r\n      return [this.collisionX, this.collisionY];\r\n    }\r\n\r\n    const target = arrayOfObjectsWithCoords[0];\r\n    const dx = target.x - this.collisionX;\r\n    const dy = target.y - this.collisionY;\r\n    const distance = Math.hypot(dx, dy);\r\n\r\n    if (distance <= this.speedModifier) {\r\n      // Игрок достиг точки удаляем ее из массива\r\n      arrayOfObjectsWithCoords.shift();\r\n    }\r\n    return [target.x, target.y];\r\n  }\r\n  paintСurvedLine(context) {\r\n    const points = [\r\n      { x: this.collisionX, y: this.collisionY },\r\n      ...this.routePoints,\r\n    ];\r\n    context.save();\r\n    context.beginPath();\r\n    context.moveTo(points[0].x, points[0].y);\r\n\r\n    for (let i = 1; i < points.length; i++) {\r\n      context.lineTo(points[i].x, points[i].y);\r\n    }\r\n\r\n    context.strokeStyle = \"#67e760c2\";\r\n    context.globalAlpha = 0.2;\r\n    context.lineWidth = 6;\r\n    context.setLineDash([10, 5]);\r\n    context.stroke();\r\n    context.restore();\r\n\r\n    context.save();\r\n    const lastPoint = points[points.length - 1];\r\n    context.beginPath();\r\n    context.arc(lastPoint.x, lastPoint.y, 8, 0, 2 * Math.PI);\r\n    context.fillStyle = \"#67e760c2\";\r\n    context.strokeStyle = \"#21691fe0\";\r\n    context.globalAlpha = 0.5;\r\n    context.stroke();\r\n    context.fill();\r\n    context.restore();\r\n  }\r\n\r\n  paintStraightLine(context) {\r\n    context.save();\r\n\r\n    context.setLineDash([10, 5]);\r\n\r\n    context.strokeStyle = \"gray\";\r\n\r\n    context.globalAlpha = 0.2;\r\n    context.beginPath();\r\n    context.moveTo(this.collisionX, this.collisionY);\r\n    context.lineTo(this.game.mouseStatus.x, this.game.mouseStatus.y);\r\n    context.stroke();\r\n    context.restore();\r\n  }\r\n\r\n  fastJump(x, y) {\r\n    if (!this.isJumping) {\r\n      this.startJumpX = this.collisionX;\r\n      this.startJumpY = this.collisionY;\r\n      this.distanceTraveled = 0;\r\n    }\r\n    this.isJumping = true;\r\n    const target = { X: x, Y: y };\r\n    const dx1 = target.X - this.collisionX;\r\n    const dy1 = target.Y - this.collisionY;\r\n    const dx2 = target.X - this.startJumpX;\r\n    const dy2 = target.Y - this.startJumpY;\r\n\r\n    const distance = Math.hypot(dx1, dy1); //сколько нужно идти\r\n    const distanceFull = Math.hypot(dx2, dy2); //сколько всего идти со старта\r\n\r\n    const maxDistance = this.jumpMaxDistance;\r\n\r\n    this.distanceTraveled = distanceFull - distance;\r\n\r\n    if (\r\n      this.distanceTraveled >= maxDistance ||\r\n      distance <= this.speedModifier + this.jumpBoost\r\n    ) {\r\n      this.isJumping = false;\r\n      this.startJumpX = null;\r\n      this.startJumpY = null;\r\n      this.distanceTraveled = 0;\r\n      this.game.jumpTimer = 0;\r\n      return [this.collisionX, this.collisionY];\r\n    }\r\n    return [x, y];\r\n  }\r\n  paintJumpLine(context) {\r\n    context.save();\r\n\r\n    context.setLineDash([10, 5]);\r\n\r\n    context.strokeStyle = \"#67e760c2\";\r\n\r\n    context.globalAlpha = 0.2;\r\n\r\n    //\r\n    //----todo refactor - код похож на метод fastJump()----\r\n    //\r\n    const target = { X: this.game.mouseStatus.x, Y: this.game.mouseStatus.y };\r\n    const dx1 = target.X - this.collisionX;\r\n    const dy1 = target.Y - this.collisionY;\r\n    const dx2 = target.X - this.startJumpX;\r\n    const dy2 = target.Y - this.startJumpY;\r\n\r\n    const distanceToTarget = Math.hypot(dx1, dy1); //сколько нужно идти\r\n    const distanceFull = Math.hypot(dx2, dy2); //сколько всего идти со старта\r\n    const distance = distanceFull - distanceToTarget; //cколько прошел\r\n\r\n    const maxDistance = this.jumpMaxDistance;\r\n    //\r\n    //------------------------------------------------------\r\n    //\r\n\r\n    context.beginPath();\r\n    context.moveTo(this.collisionX, this.collisionY);\r\n    let ratio;\r\n    if (distanceFull <= maxDistance) {\r\n      context.lineTo(target.X, target.Y);\r\n    } else {\r\n      // Иначе рисуем путь только на максимальное пройденное расстояние.\r\n\r\n      ratio = (maxDistance - distance) / distanceToTarget;\r\n      const endPointX = this.collisionX + dx1 * ratio;\r\n      const endPointY = this.collisionY + dy1 * ratio;\r\n      context.lineTo(endPointX, endPointY);\r\n    }\r\n    context.stroke();\r\n    context.restore();\r\n    context.save();\r\n\r\n    context.beginPath();\r\n    context.arc(\r\n      this.collisionX + dx1 * ratio,\r\n      this.collisionY + dy1 * ratio,\r\n      8,\r\n      0,\r\n      2 * Math.PI\r\n    );\r\n    context.fillStyle = \"#67e760c2\";\r\n    context.strokeStyle = \"#21691fe0\";\r\n    context.globalAlpha = 0.5;\r\n    context.stroke();\r\n    context.fill();\r\n    context.restore();\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://js2dgame_shooter/./src/scripts/Player.js?");

/***/ }),

/***/ "./src/scripts/domHud.js":
/*!*******************************!*\
  !*** ./src/scripts/domHud.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCastomMouse: () => (/* binding */ addCastomMouse),\n/* harmony export */   changeArmorHud: () => (/* binding */ changeArmorHud),\n/* harmony export */   changeHpHud: () => (/* binding */ changeHpHud),\n/* harmony export */   changeScoreHud: () => (/* binding */ changeScoreHud),\n/* harmony export */   changeText: () => (/* binding */ changeText),\n/* harmony export */   removeAttackMouse: () => (/* binding */ removeAttackMouse),\n/* harmony export */   removeInteractionMouse: () => (/* binding */ removeInteractionMouse),\n/* harmony export */   setAttackMouse: () => (/* binding */ setAttackMouse),\n/* harmony export */   setInteractionMouse: () => (/* binding */ setInteractionMouse),\n/* harmony export */   updateAbility: () => (/* binding */ updateAbility)\n/* harmony export */ });\n/* harmony import */ var _styles_style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../styles/style.css */ \"./src/styles/style.css\");\n \r\n\r\nfunction changeText(el, text) {\r\n  text += \"\";\r\n  el.textContent = text;\r\n}\r\n\r\n// const hpHud = document.getElementById(\"progress-bar\");\r\n\r\nfunction changeHpHud(hpNow, hpFull, hudEl) {\r\n  if (hpNow < 0) hpNow = 0;\r\n\r\n  const fillEl = hudEl.querySelector(\".progress__fill\");\r\n  const hpEl = hudEl.querySelector(\".progress__hp\");\r\n\r\n  const hpPercent = (hpNow * 100) / hpFull;\r\n  fillEl.style.width = hpPercent + \"%\";\r\n\r\n  changeText(hpEl, Math.ceil(hpNow));\r\n}\r\n\r\nfunction changeArmorHud(armorNow, hudEl, armorFull = 1000) {\r\n  if (armorNow < 0) armorNow = 0;\r\n\r\n  const fillEl = hudEl.querySelector(\".progress__fill\");\r\n  const armorEl = hudEl.querySelector(\".progress__armor\");\r\n\r\n  const armorPercent = (armorNow * 100) / armorFull;\r\n  fillEl.style.width = armorPercent + \"%\";\r\n\r\n  changeText(armorEl, Math.ceil(armorNow));\r\n}\r\nfunction changeScoreHud(score, hudEl) {\r\n  if (score < 0) score = 0;\r\n\r\n  changeText(hudEl, Math.ceil(score));\r\n}\r\nconst cursor = document.querySelector(\".cursor\");\r\nconst point = document.querySelector(\".point\");\r\n\r\nfunction addCastomMouse() {\r\n  //\r\n  const element = document.body;\r\n\r\n  function handleWheel(event) {\r\n    event.preventDefault();\r\n  }\r\n\r\n  element.addEventListener(\"wheel\", handleWheel);\r\n  //\r\n\r\n  let mouseX = 0;\r\n  let mouseY = 0;\r\n  let circleX = 0;\r\n  let circleY = 0;\r\n\r\n  const moveCursor = () => {\r\n    const easingFactor = 0.3;\r\n    const dx = mouseX - circleX;\r\n    const dy = mouseY - circleY;\r\n\r\n    circleX += dx * easingFactor;\r\n    circleY += dy * easingFactor;\r\n\r\n    cursor.style.left = circleX + \"px\";\r\n    cursor.style.top = circleY + \"px\";\r\n    point.style.left = mouseX + \"px\";\r\n    point.style.top = mouseY + \"px\";\r\n\r\n    requestAnimationFrame(moveCursor);\r\n  };\r\n  document.body.addEventListener(\"mousemove\", (e) => {\r\n    // e.preventDefault();\r\n    mouseX = e.clientX;\r\n    mouseY = e.clientY;\r\n  });\r\n  document.addEventListener(\r\n    \"contextmenu\",\r\n    (event) => {\r\n      event.preventDefault();\r\n    },\r\n    { capture: true }\r\n  );\r\n\r\n  moveCursor();\r\n}\r\n\r\nfunction setAttackMouse() {\r\n  cursor.classList.add(\"--attack\");\r\n  point.classList.add(\"--attack\");\r\n}\r\n\r\nfunction removeAttackMouse() {\r\n  cursor.classList.remove(\"--attack\");\r\n  point.classList.remove(\"--attack\");\r\n}\r\n\r\nfunction setInteractionMouse() {\r\n  document.body.style.cursor = \"none\";\r\n\r\n  cursor.classList.add(\"--interaction\");\r\n  point.classList.add(\"--interaction\");\r\n}\r\n\r\nfunction removeInteractionMouse() {\r\n  document.body.style.cursor = \"none\";\r\n\r\n  cursor.classList.remove(\"--interaction\");\r\n  point.classList.remove(\"--interaction\");\r\n}\r\nconst abilities = document.querySelector(\".abilities\");\r\nconst abilityblocks = document.querySelectorAll(\".abilities__block\");\r\n\r\nfunction updateAbility(index) {\r\n  abilityblocks.forEach((block) => {\r\n    block.classList.remove(\"--active\");\r\n  });\r\n  if (index <= 0) return;\r\n  const active = abilities.querySelector(`.abilities__block-${index}`);\r\n  active.classList.add(\"--active\");\r\n}\r\n\n\n//# sourceURL=webpack://js2dgame_shooter/./src/scripts/domHud.js?");

/***/ }),

/***/ "./src/scripts/script.js":
/*!*******************************!*\
  !*** ./src/scripts/script.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   displayBestScore: () => (/* binding */ displayBestScore)\n/* harmony export */ });\n/* harmony import */ var _Player_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Player.js */ \"./src/scripts/Player.js\");\n/* harmony import */ var _Enemy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Enemy.js */ \"./src/scripts/Enemy.js\");\n/* harmony import */ var _Obstacle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Obstacle.js */ \"./src/scripts/Obstacle.js\");\n/* harmony import */ var _MovingBarrier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MovingBarrier.js */ \"./src/scripts/MovingBarrier.js\");\n/* harmony import */ var _Game_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Game.js */ \"./src/scripts/Game.js\");\n/* harmony import */ var _domHud_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./domHud.js */ \"./src/scripts/domHud.js\");\n/* harmony import */ var _styles_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../styles/style.css */ \"./src/styles/style.css\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n \r\n\r\n\r\nwindow.addEventListener(\"load\", function () {\r\n  const hpProgressBar = document.getElementById(\"progress-bar\");\r\n  const armorProgressBar = document.getElementById(\"progress-armor-bar\");\r\n  const scoreEl = document.getElementById(\"score\");\r\n  const HudObj = { hp: hpProgressBar, score: scoreEl, armor: armorProgressBar };\r\n\r\n  const canvas = document.getElementById(\"game-field\");\r\n  const context = canvas.getContext(\"2d\");\r\n  canvas.width = 1280;\r\n  canvas.height = 720;\r\n\r\n  context.fillStyle = \"red\"; //\r\n  context.strokeStyle = \"black\";\r\n  context.lineWidth = 5;\r\n\r\n  const game = new _Game_js__WEBPACK_IMPORTED_MODULE_4__.Game(canvas, HudObj);\r\n\r\n\r\n  const blockMenu = document.querySelector('.block-menu');\r\n  const restartButton = document.querySelector('.restart-btn'); //😬\r\n  displayBestScore();\r\n  restartButton.addEventListener('click', function () {\r\n    game.gameRestart(); toggleBlockMenuVisibility();\r\n\r\n  })\r\n  game.init();\r\n\r\n  console.log(game);\r\n\r\n  let lastTime = 0;\r\n\r\n  function animate(timeStamp) {\r\n    const deltaTime = timeStamp - lastTime;\r\n    lastTime = timeStamp;\r\n    game.render(context, deltaTime);\r\n\r\n    window.requestAnimationFrame(animate);\r\n  }\r\n\r\n  animate(0);\r\n\r\n  //не игровое\r\n  //\r\n  function updateCanvasSize() {\r\n    // Устанавливаем размер холста равным размеру окна браузера\r\n    canvas.width = window.innerWidth;\r\n    canvas.height = window.innerHeight;\r\n  }\r\n  updateCanvasSize();\r\n  window.addEventListener(\"resize\", () => {\r\n    updateCanvasSize();\r\n  });\r\n\r\n  (0,_domHud_js__WEBPACK_IMPORTED_MODULE_5__.addCastomMouse)(canvas);\r\n  //\r\n  //\r\n  function toggleBlockMenuVisibility() {\r\n    blockMenu.classList.toggle('display-none');\r\n  }\r\n \r\n\r\n\r\n});\r\nfunction displayBestScore() {\r\n\r\n  const bestScore = localStorage.getItem(\"score\");\r\n\r\n  const endTxtElement = document.querySelector('.end-txt');\r\n\r\n  if (endTxtElement) {\r\n    if (bestScore !== null) {\r\n\r\n      endTxtElement.textContent = \"Лучший счет: \" + bestScore;\r\n    } else {\r\n\r\n      endTxtElement.textContent = \"Лучший счет не найден.\";\r\n    }\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://js2dgame_shooter/./src/scripts/script.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/scripts/script.js");
/******/ 	
/******/ })()
;